<file path=".github/workflows/ci.yaml">
name: Build and test

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        java: [ 11, 17, 21 ]
    name: Java ${{ matrix.java }} build
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK ${{ matrix.java }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Build with Maven on JDK ${{ matrix.java }}
        run: mvn --batch-mode --update-snapshots verify
</file>

<file path=".github/workflows/release.yaml">
name: Publish to Maven Central Repository
on: workflow_dispatch

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Maven Central Repository
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
          cache: 'maven'
          server-id: central
          server-username: CENTRAL_USERNAME
          server-password: CENTRAL_TOKEN
      - run: git config --global user.email "test@example.com"
      - run: git config --global user.name "Github Action"
      - run: echo "M2_HOME=$(dirname $(dirname `which mvn`))" >> $GITHUB_ENV
      - name: Verify package
        run: mvn --batch-mode verify
      - name: Release package
        run: mvn --batch-mode -DskipTests=true releaser:release
        env:
          CENTRAL_USERNAME: ${{ secrets.CENTRAL_USERNAME }}
          CENTRAL_TOKEN: ${{ secrets.CENTRAL_TOKEN }}
          MAVEN_GPG_PASSPHRASE: ${{ secrets.OSSRH_GPG_SECRET_KEY_PASSWORD }}
          MAVEN_GPG_KEY: ${{ secrets.OSSRH_GPG_SECRET_KEY }}
</file>

<file path="src/main/java/io/muserver/murp/Murp.java">
package io.muserver.murp;

import io.muserver.MuServer;

import java.io.InputStream;
import java.net.URI;
import java.util.Properties;

/**
 * Some utilities for the reverse proxy. If you want to create a reverse proxy, use {@link io.muserver.murp.ReverseProxyBuilder#reverseProxy()}
 *
 * @author lujunjie
 * @version $Id: $Id
 */
public class Murp {

    private Murp() {}

    private static final String version;
    static {
        String v;
        try {
            Properties props = new Properties();
            InputStream in = MuServer.class.getResourceAsStream("/META-INF/maven/io.muserver/murp/pom.properties");
            if (in == null) {
                v = "0.x";
            } else {
                try {
                    props.load(in);
                } finally {
                    in.close();
                }
                v = props.getProperty("version");
            }
        } catch (Exception ex) {
            v = "0.x";
        }
        version = v;
    }

    /**
     * Returns the current version of Murp, or 0.x if unknown
     *
     * @return murp version
     */
    public static String artifactVersion() {
        return version;
    }

    /**
     * <p>Given a gets the raw path and (if present) querystring portion of a URI.</p>
     * <p>Note: paths and query strings are not URL decoded.</p>
     *
     * @param uri The URI to get the info from
     * @return A string such as <code>/path?query=something</code>
     */
    public static String pathAndQuery(URI uri) {
        String pathAndQuery = uri.getRawPath();
        String rawQuery = uri.getRawQuery();
        if (rawQuery != null) {
            pathAndQuery += "?" + rawQuery;
        }
        return pathAndQuery;
    }
}
</file>

<file path="src/main/java/io/muserver/murp/RequestInterceptor.java">
package io.muserver.murp;

import io.muserver.MuRequest;

import java.net.http.HttpRequest;

/**
 * A hook for intercepting requests before they are sent to the target server.
 *
 * @author Daniel Flower
 * @version 1.0
 */
public interface RequestInterceptor {

    /**
     * This function is called after Murp prepared the request object to the target server, but before it is sent,
     * allowing you to modify request headers.
     * <p>Note that the request body is not available for inspection and cannot be changed as the raw bytes
     * will be streamed asynchronously to the target.</p>
     *
     * @param clientRequest The original request from the client. Note that changing anything here has no effect,
     *                      however if you want to pass data from here to a {@link io.muserver.murp.ResponseInterceptor} you can
     *                      use {@link io.muserver.MuRequest#attribute(String, Object)} to store state.
     * @param targetRequestBuilder the request builder for intercepting the request which sending to target server.
     * @throws java.lang.Exception Any unhandled exceptions will cause 500 errors
     */
    void intercept(MuRequest clientRequest, HttpRequest.Builder targetRequestBuilder) throws Exception;

}
</file>
