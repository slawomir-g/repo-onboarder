<file path=".github/workflows/ci.yaml">
name: Build and test

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        java: [ 11, 17, 21 ]
    name: Java ${{ matrix.java }} build
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK ${{ matrix.java }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Build with Maven on JDK ${{ matrix.java }}
        run: mvn --batch-mode --update-snapshots verify
</file>

<file path=".github/workflows/release.yaml">
name: Publish to Maven Central Repository
on: workflow_dispatch

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Maven Central Repository
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
          cache: 'maven'
          server-id: central
          server-username: CENTRAL_USERNAME
          server-password: CENTRAL_TOKEN
      - run: git config --global user.email "test@example.com"
      - run: git config --global user.name "Github Action"
      - run: echo "M2_HOME=$(dirname $(dirname `which mvn`))" >> $GITHUB_ENV
      - name: Verify package
        run: mvn --batch-mode verify
      - name: Release package
        run: mvn --batch-mode -DskipTests=true releaser:release
        env:
          CENTRAL_USERNAME: ${{ secrets.CENTRAL_USERNAME }}
          CENTRAL_TOKEN: ${{ secrets.CENTRAL_TOKEN }}
          MAVEN_GPG_PASSPHRASE: ${{ secrets.OSSRH_GPG_SECRET_KEY_PASSWORD }}
          MAVEN_GPG_KEY: ${{ secrets.OSSRH_GPG_SECRET_KEY }}
</file>

<file path="src/main/java/io/muserver/murp/HttpClientUtils.java">
package io.muserver.murp;

import javax.net.ssl.*;
import java.net.Socket;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

class HttpClientUtils {

    static final List<String> DISALLOWED_REQUEST_HEADERS;
    static {

        // Older JDK clients blocked headers they shouldn't. From JDK 12 these can be turned off
        // with a system property. See https://bugs.openjdk.java.net/browse/JDK-8213189
        // For JDK 11, any of "date", "from", "host", "origin", "referer", "via", "warning" will not be proxied.
        // Upgrade to JDK 12 or newer if any of these are important.
        setPropertyIfUnset("jdk.httpclient.allowRestrictedHeaders", "host,date,via,warning,from,origin,referer,connection");

        // This detects these for the current JDK and will not forward any banned ones.
        HttpRequest.Builder builder = HttpRequest.newBuilder();
        Set<String> headersThatJDKMayReject = Set.of("date", "expect", "from", "host", "origin", "referer", "via", "warning");
        List<String> disallowed = new ArrayList<>();
        for (String header : headersThatJDKMayReject) {
            try {
                builder.header(header, "dummy");
            } catch (IllegalArgumentException e) {
                disallowed.add(header);
            }
        }
        disallowed.add("content-length"); // as the body publisher adds it
        DISALLOWED_REQUEST_HEADERS = Collections.unmodifiableList(disallowed);
    }

    static String urlEncode(String value) {
        return URLEncoder.encode(value, StandardCharsets.UTF_8).replace("+", "%20");
    }

    static HttpClient.Builder createHttpClientBuilder(boolean trustAll) {

        HttpClient.Builder builder = HttpClient.newBuilder();
        if (trustAll) {
            trustAll(builder);
        }
        return builder;
    }

    private static void setPropertyIfUnset(String key, String value) {
        String custom = System.getProperty(key, null);
        if (custom == null) {
            System.setProperty(key, value);
        }
    }

    private static void trustAll(HttpClient.Builder builder) {
        try {
            final TrustManager[] trustAllCerts = new TrustManager[]{
                new X509ExtendedTrustManager()
                {
                    public X509Certificate[] getAcceptedIssuers()
                    {
                        return null;
                    }

                    public void checkClientTrusted(
                        final X509Certificate[] a_certificates,
                        final String a_auth_type)
                    {
                    }

                    public void checkServerTrusted(
                        final X509Certificate[] a_certificates,
                        final String a_auth_type)
                    {
                    }
                    public void checkClientTrusted(
                        final X509Certificate[] a_certificates,
                        final String a_auth_type,
                        final Socket a_socket)
                    {
                    }
                    public void checkServerTrusted(
                        final X509Certificate[] a_certificates,
                        final String a_auth_type,
                        final Socket a_socket)
                    {
                    }
                    public void checkClientTrusted(
                        final X509Certificate[] a_certificates,
                        final String a_auth_type,
                        final SSLEngine a_engine)
                    {
                    }
                    public void checkServerTrusted(
                        final X509Certificate[] a_certificates,
                        final String a_auth_type,
                        final SSLEngine a_engine)
                    {
                    }
                }            };
            SSLContext sslContext = SSLContext.getInstance("SSL");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            builder.sslContext(sslContext);

        } catch (NoSuchAlgorithmException | KeyManagementException e) {
            throw new RuntimeException(e);
        }
    }

}
</file>

<file path="src/main/java/io/muserver/murp/Murp.java">
package io.muserver.murp;

import io.muserver.MuServer;

import java.io.InputStream;
import java.net.URI;
import java.util.Properties;

/**
 * Some utilities for the reverse proxy. If you want to create a reverse proxy, use {@link io.muserver.murp.ReverseProxyBuilder#reverseProxy()}
 *
 * @author lujunjie
 * @version $Id: $Id
 */
public class Murp {

    private Murp() {}

    private static final String version;
    static {
        String v;
        try {
            Properties props = new Properties();
            InputStream in = MuServer.class.getResourceAsStream("/META-INF/maven/io.muserver/murp/pom.properties");
            if (in == null) {
                v = "0.x";
            } else {
                try {
                    props.load(in);
                } finally {
                    in.close();
                }
                v = props.getProperty("version");
            }
        } catch (Exception ex) {
            v = "0.x";
        }
        version = v;
    }

    /**
     * Returns the current version of Murp, or 0.x if unknown
     *
     * @return murp version
     */
    public static String artifactVersion() {
        return version;
    }

    /**
     * <p>Given a gets the raw path and (if present) querystring portion of a URI.</p>
     * <p>Note: paths and query strings are not URL decoded.</p>
     *
     * @param uri The URI to get the info from
     * @return A string such as <code>/path?query=something</code>
     */
    public static String pathAndQuery(URI uri) {
        String pathAndQuery = uri.getRawPath();
        String rawQuery = uri.getRawQuery();
        if (rawQuery != null) {
            pathAndQuery += "?" + rawQuery;
        }
        return pathAndQuery;
    }
}
</file>

<file path="src/main/java/io/muserver/murp/package-info.java">
/**
 * <p>A reverse proxy handler for Mu Server.</p>
 * <p>To create a reverse proxy, create a Mu Server and use {@link io.muserver.murp.ReverseProxyBuilder#reverseProxy()}
 * to create a handler.</p>
 * <p>For more documentation, see <a href="https://muserver.io/murp">https://muserver.io/murp</a></p>
 * @see io.muserver.murp.ReverseProxyBuilder
 */
package io.muserver.murp;
</file>

<file path="src/main/java/io/muserver/murp/ProxyCompleteListener.java">
package io.muserver.murp;

import io.muserver.MuRequest;
import io.muserver.MuResponse;

import java.net.URI;

/**
 * A listener for when proxied requests complete
 *
 * @author Daniel Flower
 * @version 1.0
 */
public interface ProxyCompleteListener {

    /**
     * Called after the response has been sent to the client, whether successful or not
     *
     * @param clientRequest The original request from the client
     * @param clientResponse The response sent to the client
     * @param targetUri The URI that this request was proxied to
     * @param durationMillis The time in millis from when the reverse proxy received the request until the client request was sent.
     * @throws java.lang.Exception Any exceptions will be logged and ignored
     */
    void onComplete(MuRequest clientRequest, MuResponse clientResponse, URI targetUri, long durationMillis) throws Exception;

}
</file>

<file path="src/main/java/io/muserver/murp/ProxyListener.java">
package io.muserver.murp;

import io.muserver.MuRequest;
import io.muserver.MuResponse;

import java.net.http.HttpRequest;
import java.nio.ByteBuffer;

/**
 * A listener for observing the life cycle phases of a request, it might be useful for debug and metric
 */
public interface ProxyListener {

    /**
     * Called before a chunk of request body data is sent to the target.
     * This will be called many times if the body has been fragmented.
     * <p>
     * For performance consideration without extra copy, the ByteBuffer chunk is the same copy as the one sending
     * to target. Async operation on the ByteBuffer chunks in this callback will have great potential to mix up the bytes.
     *
     * @param clientRequest  Client Request
     * @param clientResponse Client Response
     * @param chunk          Request body data which is going to be sent to target.
     */
    default void onBeforeRequestBodyChunkSentToTarget(MuRequest clientRequest, MuResponse clientResponse, ByteBuffer chunk) {
    }

    /**
     * Called after a chunk of request body data is sent to the target.
     * This will be called many times if the body has been fragmented.
     * <p>
     * For performance consideration without extra copy, the ByteBuffer chunk is the same copy as the one sending
     * to target. Async operation on the ByteBuffer chunks in this callback will have great potential to mix up the bytes.
     *
     * @param clientRequest  Client Request
     * @param clientResponse Client Response
     * @param chunk          Request body data which already been sent to target successfully.
     */
    default void onRequestBodyChunkSentToTarget(MuRequest clientRequest, MuResponse clientResponse, ByteBuffer chunk) {
    }

    /**
     * Called when the full request body has been sent to the target
     *
     * @param clientRequest  Client Request
     * @param clientResponse Client Response
     * @param totalBodyBytes the total sent bytes count
     */
    default void onRequestBodyFullSentToTarget(MuRequest clientRequest, MuResponse clientResponse, long totalBodyBytes) {
    }

    /**
     * Called when a chunk of response body data is received from the target
     * This will be called many times if the body has been fragmented
     *
     * @param clientRequest  Client Request
     * @param clientResponse Client Response
     * @param chunk          Response body data received from the target.
     */
    default void onResponseBodyChunkReceivedFromTarget(MuRequest clientRequest, MuResponse clientResponse, ByteBuffer chunk) {
    }

    /**
     * Called when a chunk of response body data is received from the target and sent to client
     * This will be called many times if the body has been fragmented
     *
     * @param clientRequest  Client Request
     * @param clientResponse Client Response
     * @param chunk          Response body data received from the target.
     */
    default void onResponseBodyChunkSentToClient(MuRequest clientRequest, MuResponse clientResponse, ByteBuffer chunk) {
    }

    /**
     * Called when a chunk of response body data is received from the target and fully sent to client
     *
     * @param clientRequest  Client Request
     * @param clientResponse Client Response
     * @param totalBodyBytes the total sent bytes count
     */
    default void onResponseBodyChunkFullSentToClient(MuRequest clientRequest, MuResponse clientResponse, long totalBodyBytes) {
    }

    /**
     * Called when error detected from client side
     * This API is experimental and might be changed in the future
     *
     * @param clientRequest Client Request
     * @param clientResponse Client Response
     * @param targetRequest target request
     * @param cause the error cause
     */
    default void onErrorDetectedFromClient(MuRequest clientRequest, MuResponse clientResponse, HttpRequest targetRequest, Throwable cause) {
    }

    /**
     * Called when error detected from target side
     * This API is experimental and might be changed in the future
     *
     * @param clientRequest Client Request
     * @param clientResponse Client Response
     * @param targetRequest target request
     * @param cause the error cause
     */
    default void onErrorDetectedFromTarget(MuRequest clientRequest, MuResponse clientResponse, HttpRequest targetRequest, Throwable cause) {
    }

}
</file>

<file path="src/main/java/io/muserver/murp/RequestInterceptor.java">
package io.muserver.murp;

import io.muserver.MuRequest;

import java.net.http.HttpRequest;

/**
 * A hook for intercepting requests before they are sent to the target server.
 *
 * @author Daniel Flower
 * @version 1.0
 */
public interface RequestInterceptor {

    /**
     * This function is called after Murp prepared the request object to the target server, but before it is sent,
     * allowing you to modify request headers.
     * <p>Note that the request body is not available for inspection and cannot be changed as the raw bytes
     * will be streamed asynchronously to the target.</p>
     *
     * @param clientRequest The original request from the client. Note that changing anything here has no effect,
     *                      however if you want to pass data from here to a {@link io.muserver.murp.ResponseInterceptor} you can
     *                      use {@link io.muserver.MuRequest#attribute(String, Object)} to store state.
     * @param targetRequestBuilder the request builder for intercepting the request which sending to target server.
     * @throws java.lang.Exception Any unhandled exceptions will cause 500 errors
     */
    void intercept(MuRequest clientRequest, HttpRequest.Builder targetRequestBuilder) throws Exception;

}
</file>

<file path="src/main/java/io/muserver/murp/ResponseInterceptor.java">
package io.muserver.murp;

import io.muserver.MuRequest;
import io.muserver.MuResponse;

import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

/**
 * A hook for intercepting responses before they are sent back to the client.
 *
 * @author Daniel Flower
 * @version 1.0
 */
public interface ResponseInterceptor {

    /**
     * This function is called after the response from the target is received, and the response headers for the
     * client are called. One use case is to add or remove headers or even response codes sent to the client.
     * <p>Note that the response body is not available for inspection and cannot be changed as the raw bytes
     * will be streamed asynchronously to the client.</p>
     *
     * @param clientRequest  The original request from the client.
     * @param targetRequest  The request that was sent to the target.
     * @param targetResponseInfo The responseInfo received from the target server, headers info is available.
     * @param clientResponse The as-yet unsent response to the client. You can modify the response code, content
     *                       type and other headers, however you cannot alter the response body.
     * @throws java.lang.Exception Any unhandled exceptions will be logged but will not stop the response being sent.
     */
    void intercept(MuRequest clientRequest, HttpRequest targetRequest, HttpResponse.ResponseInfo targetResponseInfo, MuResponse clientResponse) throws Exception;

}
</file>
